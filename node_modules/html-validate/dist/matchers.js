"use strict";
/* eslint-disable @typescript-eslint/no-namespace, @typescript-eslint/ban-ts-comment, prefer-template, sonarjs/no-duplicate-string */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const jest_diff_1 = __importStar(require("jest-diff")), jestDiff = jest_diff_1;
const deepmerge_1 = __importDefault(require("deepmerge"));
const lexer_1 = require("./lexer");
const htmlvalidate_1 = __importDefault(require("./htmlvalidate"));
/* istanbul ignore next: covered by compatibility tests but not a single pass */
/* @ts-ignore typing for compatibility so it will seem "impossible" but different version will yield different source */
const diff = (_a = jest_diff_1.default !== null && jest_diff_1.default !== void 0 ? jest_diff_1.default : jestDiff === null || jestDiff === void 0 ? void 0 : jestDiff.diff) !== null && _a !== void 0 ? _a : jestDiff;
/**
 * Takes all messages from all files and flattens to a single array.
 */
function flattenMessages(report) {
    return report.results.reduce((aggregated, result) => {
        return aggregated.concat(result.messages);
    }, []);
}
function toBeValid(report) {
    if (report.valid) {
        return {
            pass: true,
            message: /* istanbul ignore next */ () => "Result should not contain error",
        };
    }
    else {
        const firstError = report.results[0].messages[0];
        return {
            pass: false,
            message: () => `Result should be successful but had error "${firstError.message}"`,
        };
    }
}
function toBeInvalid(report) {
    if (report.valid) {
        return {
            pass: false,
            message: () => "Result should be invalid but had no errors",
        };
    }
    else {
        return {
            pass: true,
            message: /* istanbul ignore next */ () => "Result should not contain error",
        };
    }
}
function toHaveError(report, ruleId, message, context) {
    const actual = flattenMessages(report);
    const expected = { ruleId, message };
    if (context) {
        expected.context = context;
    }
    const matcher = [expect.objectContaining(expected)];
    const pass = this.equals(actual, matcher);
    const diffString = diff(matcher, actual, { expand: this.expand });
    const resultMessage = () => this.utils.matcherHint(".toHaveError") +
        "\n\n" +
        "Expected token to equal:\n" +
        `  ${this.utils.printExpected(matcher)}\n` +
        "Received:\n" +
        `  ${this.utils.printReceived(actual)}` +
        /* istanbul ignore next */ (diffString ? `\n\nDifference:\n\n${diffString}` : "");
    return { pass, message: resultMessage };
}
function toHaveErrors(report, errors) {
    const actual = flattenMessages(report);
    const matcher = errors.map((entry) => {
        if (Array.isArray(entry)) {
            const [ruleId, message] = entry;
            return expect.objectContaining({ ruleId, message });
        }
        else {
            return expect.objectContaining(entry);
        }
    });
    const pass = this.equals(actual, matcher);
    const diffString = diff(matcher, actual, { expand: this.expand });
    const resultMessage = () => this.utils.matcherHint(".toHaveErrors") +
        "\n\n" +
        "Expected token to equal:\n" +
        `  ${this.utils.printExpected(matcher)}\n` +
        "Received:\n" +
        `  ${this.utils.printReceived(actual)}` +
        /* istanbul ignore next */ (diffString ? `\n\nDifference:\n\n${diffString}` : "");
    return { pass, message: resultMessage };
}
function isMessage(arg) {
    return (arg &&
        (arg.ruleId ||
            arg.severity ||
            arg.message ||
            arg.offset ||
            arg.line ||
            arg.column ||
            arg.size ||
            arg.selector ||
            arg.context));
}
function isConfig(arg) {
    return (arg && (arg.root || arg.extends || arg.elements || arg.plugin || arg.transform || arg.rules));
}
function isString(arg) {
    return typeof arg === "string";
}
function toHTMLValidate(
// @ts-ignore DOM library not available
actual, arg0, arg1, arg2) {
    // @ts-ignore DOM library not available
    if (typeof HTMLElement !== "undefined" && actual instanceof HTMLElement) {
        actual = actual.outerHTML;
    }
    const message = isMessage(arg0) ? arg0 : undefined;
    const config = isConfig(arg0) ? arg0 : isConfig(arg1) ? arg1 : undefined;
    const filename = isString(arg0) ? arg0 : isString(arg1) ? arg1 : arg2;
    return toHTMLValidateImpl.call(this, actual, message, config, filename);
}
function toHTMLValidateImpl(actual, expectedError, userConfig, filename) {
    const defaultConfig = {
        rules: {
            /* jsdom normalizes style so disabling rule when using this matcher or it
             * gets quite noisy when configured with self-closing */
            "void-style": "off",
        },
    };
    const config = deepmerge_1.default(defaultConfig, userConfig || {});
    const actualFilename = filename || this.testPath;
    const htmlvalidate = new htmlvalidate_1.default();
    const report = htmlvalidate.validateString(actual, actualFilename, config);
    const pass = report.valid;
    if (pass) {
        return { pass, message: () => "HTML is valid when an error was expected" };
    }
    else {
        if (expectedError) {
            const matcher = expect.arrayContaining([expect.objectContaining(expectedError)]);
            const errorPass = this.equals(report.results[0].messages, matcher);
            const diffString = diff(matcher, report.results[0].messages, {
                expand: this.expand,
                aAnnotation: "Expected error",
                bAnnotation: "Actual error",
            });
            const hint = this.utils.matcherHint(".not.toHTMLValidate", undefined, undefined, {
                comment: "expected error",
            });
            const expectedErrorMessage = () => [
                hint,
                "",
                "Expected error to be present:",
                this.utils.printExpected(expectedError),
                /* istanbul ignore next */ diffString ? `\n${diffString}` : "",
            ].join("\n");
            return { pass: !errorPass, message: expectedErrorMessage };
        }
        const errors = report.results[0].messages.map((message) => `  ${message.message} [${message.ruleId}]`);
        return {
            pass,
            message: () => ["Expected HTML to be valid but had the following errors:", ""].concat(errors).join("\n"),
        };
    }
}
function toBeToken(actual, expected) {
    const token = actual.value;
    // istanbul ignore next: TokenMatcher requires "type" property to be set, this is just a failsafe
    if (token.type) {
        token.type = lexer_1.TokenType[token.type];
    }
    // istanbul ignore next: TokenMatcher requires "type" property to be set, this is just a failsafe
    if (expected.type) {
        expected.type = lexer_1.TokenType[expected.type];
    }
    const matcher = expect.objectContaining(expected);
    const pass = this.equals(token, matcher);
    const diffString = diff(matcher, token, { expand: this.expand });
    const message = () => this.utils.matcherHint(".toBeToken") +
        "\n\n" +
        "Expected token to equal:\n" +
        `  ${this.utils.printExpected(matcher)}\n` +
        "Received:\n" +
        `  ${this.utils.printReceived(token)}` +
        /* istanbul ignore next */ (diffString ? `\n\nDifference:\n\n${diffString}` : "");
    return { pass, message };
}
expect.extend({
    toBeValid,
    toBeInvalid,
    toHaveError,
    toHaveErrors,
    toHTMLValidate,
    toBeToken,
});
//# sourceMappingURL=matchers.js.map