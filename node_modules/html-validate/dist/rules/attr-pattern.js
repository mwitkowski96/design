"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_PATTERN = void 0;
const rule_1 = require("../rule");
exports.DEFAULT_PATTERN = "[a-z0-9-:]+";
const defaults = {
    pattern: exports.DEFAULT_PATTERN,
    ignoreForeign: true,
};
function generateRegexp(pattern) {
    if (Array.isArray(pattern)) {
        /* eslint-disable-next-line security/detect-non-literal-regexp */
        return new RegExp(`^(${pattern.join("|")})$`, "i");
    }
    else {
        /* eslint-disable-next-line security/detect-non-literal-regexp */
        return new RegExp(`^${pattern}$`, "i");
    }
}
function generateMessage(name, pattern) {
    if (Array.isArray(pattern)) {
        return `Attribute "${name}" should match one of [${pattern.map((it) => `/${it}/`).join(", ")}]`;
    }
    else {
        return `Attribute "${name}" should match /${pattern}/`;
    }
}
function generateDescription(name, pattern) {
    if (Array.isArray(pattern)) {
        return [
            `Attribute "${name}" should match one of the configured regular expressions:`,
            "",
            ...pattern.map((it) => `- \`/${it}/\``),
        ].join("\n");
    }
    else {
        return `Attribute "${name}" should match the regular expression \`/${pattern}/\``;
    }
}
class AttrPattern extends rule_1.Rule {
    constructor(options) {
        super(Object.assign(Object.assign({}, defaults), options));
        this.pattern = generateRegexp(this.options.pattern);
    }
    static schema() {
        return {
            pattern: {
                oneOf: [{ type: "array", items: { type: "string" }, minItems: 1 }, { type: "string" }],
            },
            ignoreForeign: {
                type: "boolean",
            },
        };
    }
    documentation(context) {
        let description;
        if (context) {
            description = generateDescription(context.attr, context.pattern);
        }
        else {
            description = `Attribute should match configured pattern`;
        }
        return {
            description,
            url: rule_1.ruleDocumentationUrl(__filename),
        };
    }
    setup() {
        this.on("attr", (event) => {
            if (this.isIgnored(event.target)) {
                return;
            }
            /* ignore case for dynamic attributes, the original attributes will be
             * checked instead (this prevents duplicated errors for the same source
             * attribute) */
            if (event.originalAttribute) {
                return;
            }
            if (this.pattern.test(event.key)) {
                return;
            }
            const message = generateMessage(event.key, this.options.pattern);
            this.report(event.target, message, event.keyLocation);
        });
    }
    isIgnored(node) {
        if (this.options.ignoreForeign) {
            return Boolean(node.meta && node.meta.foreign);
        }
        else {
            return false;
        }
    }
}
exports.default = AttrPattern;
//# sourceMappingURL=attr-pattern.js.map